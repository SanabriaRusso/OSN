% Chapter Template

\chapter{Open Sensor Network} % Main chapter title

\label{Chapter5} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

\lhead{Chapter 5. \emph{Open Sensor Network}} % Change X to a consecutive number; this is for the header on each page - perhaps a shortened title

%----------------------------------------------------------------------------------------
%	INTRODUCTION
%----------------------------------------------------------------------------------------

The result of working on this pilot is a set of tools (e.g.\ server script, schematics, Arduino program, etc.) that can be used to easily deploy a sensor network with well-tested and mature solutions that automatically uploads the information to the Internet. The two main features that define this network are:

\begin{itemize}
    \item Ease of deployment --- The server runs a general purpose Python script that doesn't care of the actual information it receives. Instead, it just uploads data to the selected webpages. To deploy such a network, only the XBee\textregistered{} radios have to be configured correctly, as well as wiring the circuits accordingly. There is no need to focus on the underlying details of information transmission.
    \item Flexibility --- The system is prepared to transmit heterogeneous information. Each node is able to transmit different information and the sink will decode it anyway. This allows a community to gather what each individual wants or to achieve better granularity where needed. That is, someone might be interested in measuring temperature every two blocks and humidity every four blocks.
\end{itemize}

In the following sections, everything concerning this network will be explained in detail: feasible scenarios, how to configure the XBee radios, how does the sink script work, etc.

%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Network topology}

Network topology refers to the way nodes that conform the system are arranged, thus it is clear that this factor will determine very important components about the network, such as reliability, modularity, fault occurence, etc. The use of Digi Xbee\textregistered{} RF modules enables the network to be configured in any kind of topology, from a simple ring to a complex mesh\footnote{Networks where a packet can follow more than one path to reach its destination.}. An example of a mesh network is depicted in figure \ref{fig:MeshNet}, where each circle represents a node and the lines the wireless links between them.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.35]{./Figures/mesh_network.png}
        \rule{35em}{0.5pt}
    \caption[Mesh Network]{An example of a mesh network.}
    \label{fig:MeshNet}
\end{figure}

As these RF devices only allow one single sink per network, not making use of mesh topologies would be an enormous drawback, since packet delivery would be subject to other nodes availability. Luckily, ZigBee specification allows that some nodes act as a relay for other nodes, enabling us to build complex networks with redundant paths. This statement, translated to battery-powered systems means that the more relay nodes a network has, the more prolonged the network's lifetime will be\citep{hou2005energy}, since relay nodes will have to pass on less messages.


A mesh sensor network of this kind can be fully connected ---each node is connected to every other one--- or partially connected. This topology, as defined in the ZigBee specification have many advantages. They basically enable the system to be:

\begin{itemize}
    \item Self-healing --- Allows the network to operate when a node goes down.
    \item Self-routing --- When a packet is transmitted or forwarded, the route that it follows is created ---that is, calculated--- locally within every node.
    \item Self-forming --- Nodes that are new to the network create links automatically with the rest of nodes and routes are created dinamically as well.
\end{itemize}

%-----------------------------------
%	SUBSECTION 1
%-----------------------------------
\subsection{Device roles}

Inside an ZigBee network there are three roles that a node can assume: coordinator, router and end device.

A \emph{coordinator} is the sink of the network, and as stated before, only one is allowed per network. A coordinator stores vital information about the network, acts as well as the trust center\footnote{Stores the keys if encryption is enabled, deciding who may or may not join the network.} and manages network security in general\citep{sensornetworktc}. In this case, it will be connected to the Raspberry Pi so data can be processed and uploaded to the Internet.

A \emph{router} has the same function as the previously mentioned relay nodes. It can generate and transmit data by itself to other router or a coordinator but it is also able to forward packets from other nodes. If the network is very redundant it should not be a problem having a battery-powered router.

Finally, an \emph{end device} is the least capable device of all. It can only transmit information that will be or will not be forwarded, thus they are always on the edge of the network. Since no other node depends on an end device, they can make use of the \emph{sleep mode}. This mode allows an XBee radio to wake up every certain amout of time thus saving a lot of power.

An example of such a network can be seen in figure \ref{fig:ZBeeNet}.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.7]{./Figures/zigbee_topology.png}
        \rule{35em}{0.5pt}
        \caption[ZigBee network example]{An example of an ZigBee network, taken from the ZigBee Alliance website (\url{http://zigbee.org}).}
    \label{fig:ZBeeNet}
\end{figure}

%----------------------------------------------------------------------------------------
%	SECTION 2
%----------------------------------------------------------------------------------------

\section{Sensor nodes}

A sensor node is an element inside a wireless sensor network that is capable of cathering information, has some processing power and can relay information (if needed) to other nodes in the network\citep{chong2003sensor}.

In the design of this network two feasible scenarios have been considered, depending on which kind of sensors need to be used ---whether they are digital or analogic---, and if processing power is required.

In case at least one of those features is needed, an Arduino plus an XBee\textregistered{} module are coupled together, with sensors attached to the board. Otherwise a standalone XBee\textregistered{} is used since it has a built-in ADC\footnote{An analog-to-digital converter takes a continous value --voltage, in our case-- as its input and converts it to a digital numeral.}, hence being able to directly read information from analog sensors.

These two operational modes have been taken in consideration because despite one of them can equate the other's characteristics one can think of some applications where the features of an additional microcontroller are just not needed. For instance, a sensor network monitoring temperature in an industrial environment just needs the so-mentioned analog-to-digital converter and a transceiver. Although there are two types of nodes, both can be used at the same time inside a given network.

To configure the radio of a sensor node one must use X-CTU, a piece of software developed by Digi International that, although it is intended to be run on Windows, it works fine on GNU/Linux using Wine\footnote{Wine is open source software that helps running Microsoft Windows applications on Unix-like operating systems.}, as it can be seen in figure \ref{fig:xctuonubuntu}.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.6]{./Figures/xctuonubuntu.png}
        \rule{35em}{0.5pt}
        \caption[Screenshot of X-CTU]{A screenshot of X-CTU running on Ubuntu 12.04 under Wine.}
    \label{fig:xctuonubuntu}
\end{figure}

%-----------------------------------
%	SUBSECTION 1
%-----------------------------------
\subsection{Standalone XBee}

As mentioned in section \ref{sec:xbee}, any XBee device has two modes of operation, namely API and transparent. We will be using API mode, which provides several advantages:

\begin{itemize}
    \item When the coordinator receives a packet, it immediately transmits an ACK\footnote{Acknowledgement packets are used to indicate that the transmission was successful.} packet. If such packet is not received then transmitting radio will retry sending it.
    \item Radios can be re-configured dinamically over the air.
    \item Checksums that verify that no errors have been introduced. In other words, it checks the received information is the same than the one that was originally transmitted.
    \item Encryption (using a symmetric key algorithm) can be enabled, either using one pre-established key or getting one from the network coordinator.
    \item I/O samples, which enable us to use all the DIO\footnote{Although DIO stands for digital input/output, some of them can handle continous values through the ADC.} pins that the module has.
\end{itemize}

This last feature is the one we will be abusing the most. In figure \ref{fig:XBeeBO} we can observe the pinout of an XBee radio, with all its DIO pins. For analog input, we can only use from \texttt{DIO0} (sometimes called as well \texttt{AD0}) to \texttt{DIO3} (or \texttt{AD3}).

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.25]{./Figures/xbee_breakout.jpg}
        \rule{35em}{0.5pt}
    \caption[XBee pinout]{XBee pinout, seen from a breakout board.}
    \label{fig:XBeeBO}
\end{figure}

An schematic of this node can be seen below (figure \ref{fig:StandaloneXBee}), where only light level and temperature are measured. This particular setup could be useful to prevent fires in forests, although the optimal setup should have a humidity sensor as well.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.6]{./Figures/standalonexbee.png}
        \rule{35em}{0.5pt}
    \caption[Standalone XBee]{A standalone XBee node.}
    \label{fig:StandaloneXBee}
\end{figure}

Using a battery and a solar panel to power a sensor node like this one, along with \emph{sleep mode} can result in very long lifetimes.

\subsubsection{Configuring a standalone XBee\textregistered{}}
The first step is lo flash the radio module with the correct firmware, that is, with the \texttt{ZB} firmware. \texttt{ZB} firmware implements the ZigBee 2007 specification\footnote{At the time of writing, the latest specification is from 2012.}.

To configure a standalone node one must connect it to X-CTU ensure that it is has the same \texttt{PANID} than the coordinator ---that is, in the same network---. Also, API mode shall be enabled, thus setting the \texttt{AP} parameter to \texttt{2}, which means not only that API mode must be used but also \emph{escaping}.

With escaping mode enabled the system escapes some special characters. In other words, if special characters appear in the packet ---for instance \texttt{0x7E}, which serves as a start frame delimiter--- they are replaced by other sequences so they can be decoded as well by the receiver but without causing any trouble in the interpretation phase. Receiving an arbitrary \texttt{0x7E} could pose many problems for the receiver. It would not know when a packet really starts\citep{digi:escapedchars}.

Some example configuration files were exported from X-CTU and can be freely downloaded from the original git repository\footnote{\url{https://github.com/aandreuisabal/OSN}} (hosted in GitHub).

%-----------------------------------
%	SUBSECTION 2
%-----------------------------------
\subsection{Arduino-based node}

Arduino is capable of executing C code, thus being able to process any kind of information no matter how complex it is (always bearing in mind its hardware limits). To transmit all the information, the RF module attached to it will be configured in API mode.

As a proof of concept, the example setup I have worked with has an analog sensor that measures sound levels (\ref{sub:sound}), another one that measures air quality in terms of fine particles in the air (\ref{sub:sharp}) and a digital sensor that reads humidity and temperature (\ref{sub:dht}). The elements that conform except the air quality sensor are arranged as depicted in figure \ref{fig:ArduinoNode}.

% TODO - Conseguir modelo de Fritzing para SHARP GP2Y1010AU0F
\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.8]{./Figures/completesensornode.png}
        \rule{35em}{0.5pt}
    \caption[Arduino-based node schematic]{Sensor node based on Arduino.}
    \label{fig:ArduinoNode}
\end{figure}

This type of node has the same communication features as the standalone XBee. That is, encryption, acknowledgements, etc. In particular, ACKs are better handled in this case since an Arduino can \emph{react} to them.

\subsubsection{Arduino sketch}
A sketch is nothing more than the program an Arduino runs. The basic code is written in C/C++, and it consists of a main file ---with \texttt{.ino} extension--- and the XBee\textregistered{} libraries. The code can be browsed and downloaded via GitHub. There are two versions of the sketch:

\begin{itemize}
    \item Exact same code I used to conduct the experiments, so anyone can verify and/or test the obtained results.
    \item A skeleton file, that follows a very minimalistic approach in terms of lines of code but fully commented. This way, it can be extended as desired to build a sensor network from scratch with customized sensor nodes.
\end{itemize}

Arduino IDE is based on Processing IDE\footnote{\url{http://processing.org}}, and it follows the same structure than the Processing programming language. There are two main functions necessary for every program to work, namely \texttt{setup()} and another one called \texttt{loop()}. Respectively:

\begin{itemize}
    \item The \texttt{setup()} funcion initializes variables, modules (such as the XBee), libraries and sets pins in specific modes. After this function is successfully executed \texttt{loop()} is immediately called.
    \item \texttt{loop()} is a function that as its own name indicates, is executed over and over again. Thus inside this structure is where the action takes place. 
\end{itemize}

Before even \texttt{setup()} starts, the following steps take place:

\begin{itemize}
    \item An object of type \texttt{XBee} is created, so serial information can be exchanged between the microcontroller and the RF module. 
    \item Additional information useful for the transmission is set: destination address, how big the packet will be, etc.
    \item Also, an array called \texttt{payload} is initialized, which will contain all readings as well as some \emph{metadata}. 
    \item The variables that will hold the different readings are also declared outside the two main function so they are recognized in a global scope.
    \item Finally, necessary C unions\footnote{An union allows us to represent information in more than one way. In our case it helps us convert integers, booleans, etc. into byte-level data.} are created. One for every compatible data type.
\end{itemize}

In our \texttt{setup()} step we initialize a serial connection with the XBee\textregistered{} and set a pin to act as digital output. This pin is the number \texttt{13}, which is connected to the on-board LED.

Then, in \texttt{loop()} all sensory values are recollected and then transmitted via a ZigBee packet. Finally if the previously mentioned LED blinks once that will mean transmission took place successfully, otherwise it will blink twice. This last feature is especially interesting when debugging.

In figure \ref{fig:ArduinoProgram} it is depicted how the program works in more detail. This flow diagram follows a top-down approach. That is, from general to more specific functions.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.43]{./Figures/SensorNodeDia.png}
        \rule{35em}{0.5pt}
    \caption[Flow diagram of an Arduino-based node]{Flow diagram of the Arduino program.}
    \label{fig:ArduinoProgram}
\end{figure}

As for how values are read from the Arduino, figure \ref{fig:readvalues} explains how this process takes place step by step. Basically, digital values are read one time since the readings are more precise, and when reading an analog value the Arduino computes an average of \texttt{n} samples to smoothe the values from ``jumpy'' sensors.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.38]{./Figures/readvalues.png}
        \rule{35em}{0.5pt}
    \caption[Value reading flowchart]{Flowchart of how values are read.}
    \label{fig:readvalues}
\end{figure}

Since an initial requirement was that each sensor node can transmit whatever it needs to, I designed a rudimentary but efficient mechanism. At the start of every packet, an integer is sent. This is the only fixed value that every packet will hold. This integer, represented by several digits, will be tremendously helpful so the sink knows how to decode the payload ---keep in mind that data is expressed in binary form---.

To come up with an actual way to translate between digits and data types, I had a look at which data types Python structures and Arduino shared. The results are shown in table \ref{tab:mapnumbers}. For more information on supported data types one can visit the reference on the official Arduino webpage\footnote{\url{http://arduino.cc/en/Reference/HomePage}} and Python documentation on data structures\footnote{\url{http://docs.python.org/2/library/struct.html}}.

So if for instance, a node wants to transmit two floats and a boolean it can transmit \texttt{199} as the first number or also \texttt{991}, depending on the actual order of the values in the payload. Nonetheless, it is recommended to transmit first the data types that are represented by the smallest digits ---from \texttt{1}, \texttt{2}\ldots\texttt{9}, \texttt{0}--- so the range of an integer is not exceeded and data can be unpacked correctly.

\begin{table}[ht] 
\centering
\begin{tabular}{c|l}
Number          & Data type             \\
\hline
1               & \texttt{boolean}      \\
2               & \texttt{char}         \\
3               & \texttt{unsigned char}\\
4               & \texttt{int}          \\
5               & \texttt{unsined int}  \\
6               & \texttt{long}         \\
7               & \texttt{unsigned long}\\
8               & \texttt{short}        \\
9               & \texttt{float}        \\
0               & \texttt{double}       \\
\end{tabular}
\caption{Mapping between numbers and data types.}
\label{tab:mapnumbers}
\end{table}


%----------------------------------------------------------------------------------------
%	SECTION 1
%----------------------------------------------------------------------------------------

\section{Network sink}

The sink is where all the information is headed. As stated in the previous section, it is composed of a Raspberry Pi with an XBee module connected to it. The schematic, although simple can be seen in the figure \ref{fig:sinkrpi}. Note that in the figure there is not an XBee but a breakout board for it that has a miniUSB interface, very useful for our purposes. On top of it there is the actual XBee\textregistered{}.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.7]{./Figures/server_side.png}
        \rule{35em}{0.5pt}
    \caption[Raspberry Pi based sink]{Schematic of the sink.}
    \label{fig:sinkrpi}
\end{figure}

The GNU/Linux distribution that has been chosen to operate in this device is Arch Linux ARM, as stated in section \ref{sec:alarmmm}. Its repositories are huge because regular users contribute to a non-official repository, called ``Arch User Repository'' (also known as AUR). There, all the packages mentioned in chapter \ref{Chapter3} are available without compiling from source ---in the form of binaries---.

The script, called \texttt{server.py} is then run as a daemon which will be always receiving information. It needs two arguments:

\begin{itemize}
    \item Device file that interfaces with the XBee\textregistered{} (e.g. \texttt{/dev/ttyUSB0}). Depending on the devices already attached to the computer the last number might change.
    \item Baud rate the XBee\textregistered{} is working at (e.g. \texttt{9600}). Can be customized via X-CTU.
\end{itemize}

What the script basically does is run an asynchronous \texttt{XBee} dispatcher, which will create a new background thread for every new packet that arrives, thus enabling the sink to process many packets at the same time without blocking the whole script. The program is quite modular, since it allows to upload the information to the website the user wants by just uncommenting certain lines. A more detailed view on how it generally works can be seen in figure \ref{fig:sindia}.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.44]{./Figures/sindia.png}
        \rule{35em}{0.5pt}
    \caption[Flow diagram of the sink script]{Flow diagram of the sink script.}
    \label{fig:sindia}
\end{figure}

However, in figure \ref{fig:sindia} we cannot appreciate how packets are actually handled, and what happens to them afterwards. For that matter, figures \ref{fig:phandler} and \ref{fig:puploader} explain these two phases more precisely.

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.38]{./Figures/packet_handler.png}
        \rule{35em}{0.5pt}
    \caption[Packet dispatcher flowchart]{Flowchart of how packets are dispatched.}
    \label{fig:phandler}
\end{figure}

\begin{figure}[htbp]
    \centering
        \includegraphics[scale=0.38]{./Figures/packet_uploader.png}
        \rule{35em}{0.5pt}
    \caption[Packet uploader flowchart]{How a packet uploader works.}
    \label{fig:puploader}
\end{figure}

\subsection{Setting up the sink}



\section{Deploying the network}
